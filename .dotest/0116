From fa995d57aee6b23ab5eee085e454bddea963eba7 Mon Sep 17 00:00:00 2001
From: Ross Riley <rossriley@Macintosh.home>
Date: Sun, 6 Apr 2008 22:48:57 +0100
Subject: Work on new WaxUrl
 Cleanup of deprecated files

---
 wax/AutoLoader.php                  |   10 -
 wax/WXMigrate.php                   |  342 -------------------------------
 wax/WXValidations.php               |  155 --------------
 wax/helpers/JQueryHelper.php        |  287 --------------------------
 wax/helpers/JavascriptHelper.php    |   63 ------
 wax/helpers/PrototypeHelper.php     |  384 -----------------------------------
 wax/helpers/ScriptaculousHelper.php |  234 ---------------------
 wax/tests/TestWaxUrl.php            |   48 +++--
 8 files changed, 27 insertions(+), 1496 deletions(-)
 delete mode 100755 wax/WXMigrate.php
 delete mode 100644 wax/WXValidations.php
 delete mode 100755 wax/helpers/JQueryHelper.php
 delete mode 100644 wax/helpers/JavascriptHelper.php
 delete mode 100755 wax/helpers/PrototypeHelper.php
 delete mode 100755 wax/helpers/ScriptaculousHelper.php

diff --git a/wax/AutoLoader.php b/wax/AutoLoader.php
index ac431d9b51a5aaa1d7bdd740ef4764161283554f..82ac85f1e86e4deff99c59bb17d6a13e5edc4bf8 100755
--- a/wax/AutoLoader.php
+++ b/wax/AutoLoader.php
@@ -162,15 +162,6 @@ class AutoLoader
 	  }
 	}
 	
-	static public function register_ajax_helpers() {
-	  if(!$libs = WXConfiguration::get("ajax_libraries")) {
-      self::include_from_registry('PrototypeHelper');
-      self::include_from_registry('ScriptaculousHelper');
-    } else {
-      foreach($libs as $lib) Autoloader::include_from_registry(ucfirst($lib).Helper);
-    }
-	}
-	
 	static public function initialise() {	  
 		self::detect_assets();
 	  self::detect_test_mode();
@@ -183,7 +174,6 @@ class AutoLoader
 		self::detect_environments();
 		self::include_from_registry('WXInflections');  // Bit of a hack -- forces the inflector functions to load
 		self::include_from_registry('WXHelpers');  // Bit of a hack -- forces the helper functions to load
-		self::register_ajax_helpers();
 		self::register_helpers();
 		set_exception_handler('throw_wxexception');
 		set_error_handler('throw_wxerror', 247 );		
diff --git a/wax/WXMigrate.php b/wax/WXMigrate.php
deleted file mode 100755
index 6fcf868e72c3677ff525022f2d76dcf9fa489db2..0000000000000000000000000000000000000000
--- a/wax/WXMigrate.php
+++ /dev/null
@@ -1,342 +0,0 @@
-<?php
-/**
-  *  @package PHP-Wax
-  *  Migration Class maintains database structure according to a 'version control methodology'
-  *  Ideal for ensuring that database structures are maintained across multiple servers.
-  *
-  */
-  
-class WXMigrate
-{
-  protected $pdo;
-  protected $version;
-  protected $migration_dir;
-  protected $migrations_array = array();
-  protected $columns_array = array();
-  public $quiet_mode = false;
-  
-  public function __construct($quiet = false) {
-    if($quiet) $this->quiet_mode = true;
-    $this->pdo = WXActiveRecord::getDefaultPDO();
-    if(!$this->check_schema()) {
-      $this->create_schema();
-    }
-  }
-  
-  public function check_schema() {
-    $sth = $this->pdo->query("show tables");
-    while($table = $sth->fetch()) {
-      if($table[0] == "migration_info") {
-        return true;
-      }
-    }
-    return false;
-  }
-  
-  protected function create_schema() {
-    $this->pdo->query("CREATE TABLE `migration_info` (`version` INT(7) unsigned NOT NULL default '0', 
-                      `version_latest` INT(7) unsigned NOT NULL default '0', PRIMARY KEY  (`version`))");
-    $this->pdo->query("INSERT INTO `migration_info` (`version`, `version_latest`) VALUES (0,0)");    
-  }
-  
-  public function get_version() {
-    $row = $this->pdo->query("SELECT version FROM migration_info")->fetch();
-    return $row['version'];
-  }
-  
-  public function set_version($version) {
-    $this->pdo->query("UPDATE migration_info SET version=".$version);
-  }
-  
-  public function increase_version() {
-    $version = $this->get_version() + 1;
-    $this->pdo->query("UPDATE migration_info SET version=".$version);
-    return $version;
-  }
-  
-  public function decrease_version() {
-    if($this->get_version()>0) {
-      $version = $this->get_version() - 1;
-      $this->pdo->query("UPDATE migration_info SET version=".$version);
-    } else {
-      $version = 0;
-    }
-    return $version;
-  }
-  
-  public function get_version_latest() {
-    $row = $this->pdo->query("SELECT version_latest FROM migration_info")->fetch();
-    return $row['version_latest'];
-  }
-  
-  public function increase_version_latest() {
-    $latest_ver = $this->get_version_latest() + 1;
-    return $this->pdo->query("UPDATE migration_info SET version_latest=".$latest_ver);
-  }
-  
-  public function create_migration($name) {
-    $latest_ver = $this->get_version_latest() + 1;
-    $this->pdo->query("UPDATE migration_info SET version_latest=".$latest_ver);
-    $name = ucfirst(WXActiveRecord::camelize($name));
-    $text = "<?php".                          "\n";
-    $text.= "class {$name} extends WXMigrate"."\n";
-    $text.= "{".                              "\n";
-    $text.= "  public function up() {".       "\n";
-    $text.=                                   "\n";
-    $text.= "  }".                            "\n";
-    $text.=                                   "\n";
-    $text.= "  public function down() {".     "\n";
-    $text.=                                   "\n";
-    $text.= "  }".                            "\n";
-    $text.= "}".                              "\n";
-    $text.= "?>".                              "\n";
-    return $text;
-  }
-  
-  protected function get_version_from_file($file) {
-    return ltrim(substr($file, 0 , strpos($file, "_")), "0");
-  }
-  
-  protected function get_class_from_file($file, $strip = true) {
-    if($strip) $file = substr($file,3);
-    return WXInflections::camelize(str_replace(".php", "", $file), true);
-  }
-  
-  protected function create_migration_array($directory) {   
-    $migrations=File::scandir_recursive($directory);
-    foreach($migrations as $migration) {
-      $version_number_of_file = $this->get_version_from_file($migration);
-      $class_name = $this->get_class_from_file($migration);
-      $this->migrations_array[$version_number_of_file] = array("file"=>$migration, "class"=>$class_name, "version"=>$version_number_of_file);
-    }
-  }
-  
-  protected function get_highest_version() {
-    ksort($this->migrations_array);
-    $high =  end($this->migrations_array);
-    return $high['version'];
-  }
-  
-  public function migrate_revert($directory) {
-    $this->create_migration_array($directory);
-    krsort($this->migrations_array);
-    foreach($this->migrations_array as $migration) {
-      if($migration['version'] <= $this->get_version()) {
-        include_once($directory.$migration['file']);
-        $this->migrate_down(new $migration['class'], $migration['version']);
-      }
-    }
-    $this->set_version("0");
-    return "0";
-  }
-
-  public function version_less_migrate($directory, $direction="up", $quiet=false) {
-    if(!is_readable($directory)) return "Invalid directory";
-    $migrations=File::scandir_recursive($directory);
-    if(count($migrations)<1) return "No migrations in supplied directory";
-    foreach($migrations as $migration) {
-      if(!strpos($migration, ".php")) return "Only directories of PHP migration files are allowed"; 
-      include_once($directory.$migration);
-      $class = $this->get_class_from_file($migration, false);
-      $instance = new $class($quiet);
-      $instance->{$direction}();
-    }
-    return "Database setup completed";
-  }
-  
-  public function migrate($directory, $target_version=false) {
-    $this->create_migration_array($directory);
-    if($target_version===false) {
-      $target_version = $this->get_highest_version();
-    }
-    if($target_version==$this->get_version()) {
-      return false;
-    }  
-    if(count($this->migrations_array)<1) {
-      return false;
-    }
-    if($target_version > $this->get_highest_version() || !array_key_exists($target_version, $this->migrations_array)) {
-      $this->output( "...version given does not exist."."\n");
-      return false;
-    }
-    
-    $this->output( "...current version: ".$this->get_version()."\n"."...now moving to version: ".$target_version."\n");
-    if($target_version < $this->get_version()) {
-      $direction = "down";
-      krsort($this->migrations_array);
-    } else {
-      ksort($this->migrations_array);
-      $direction = "up";
-    }
-    if($direction == "down") {
-      foreach($this->migrations_array as $migration) {
-        include_once($directory.$migration['file']);
-        if($migration['version'] == $target_version) {
-          $running_version = $migration['version'];
-        }
-        if($migration['version'] > $target_version && $migration['version'] <= $this->get_version()) {
-          $this->migrate_down(new $migration['class'], $migration['version']);
-          $running_version = $migration['version'];
-        }
-      }
-    } else {
-      foreach($this->migrations_array as $migration) {
-        include_once($directory.$migration['file']);
-        if($migration['version'] == $target_version) {
-          $running_version = $migration['version'];
-        }
-        if($migration['version'] > $this->get_version() && $migration['version'] <= $target_version) {
-          $this->migrate_up(new $migration['class'], $migration['version']);
-          $running_version = $migration['version'];
-        }
-      }
-    }
-    $this->set_version($running_version);
-    return $running_version;
-  }
-  
-  private function migrate_down(WXMigrate $class, $version) {
-    $this->output( "...reverting with version ".$version."\n");
-    $class->down();
-    $this->set_version($version);
-    return true;
-  }
-  
-  private function migrate_up(WXMigrate $class, $version) {
-    $this->output( "...updating with version ".$version."\n");
-    $class->up();
-    $this->set_version($version);
-    return true;
-  }
-  
-  private function build_column_sql($column) {
-    $sql = "`".$column[0]."` ";
-    switch($column[1]) {
-      case "string": $sql.= "VARCHAR "; break;
-      case "integer": $sql.= "INT "; break;
-      case "text": $sql.= "TEXT "; $column[2]=null; break;
-      default: $sql.= $column[1]." "; $column[2]=null;
-    }
-    if($column[2]) {
-      $sql.= "({$column[2]}) ";
-    }
-    if($column[3]) {
-      $sql.= "NULL ";
-    } else {
-      $sql.= "NOT NULL ";
-    }
-    if(isset($column[4])) {
-      $sql.= "DEFAULT '".$column[4]."' ";
-    }
-    return $sql;
-  }
-  
-  public function create_table($table_name, $id=true) {
-    try {
-      $sql = "CREATE TABLE IF NOT EXISTS `$table_name`(";
-      if($id) $sql.= "`id` INT( 11 ) NOT NULL AUTO_INCREMENT PRIMARY KEY";
-      if(count($this->columns_array) > 0) {
-        if($id) $sql.= ", ";
-        foreach($this->columns_array as $column) {
-          $sql.= $this->build_column_sql($column);
-          $sql.= ",";
-        }
-      }
-      $this->columns_array = array();
-      $sql = rtrim($sql, ",");
-      $sql.= ")";
-      $this->pdo->query($sql);
-      $this->output( "...created table $table_name"."\n");
-			return true;
-    } catch(Exception $e) {
-      $e = false; return $e;
-    }
-  }
-  
-  public function drop_table($table_name) {
-    $sql = "DROP TABLE IF EXISTS `$table_name`";
-    $this->pdo->query($sql);
-    $this->output( "...removed table $table_name"."\n" );
-  }
-  
-  public function create_column($name, $type="string", $length = "128", $null=true, $default=null) {
-		$name = str_replace(" ", "", $name);
-    $this->columns_array[] = array($name, $type, $length, $null, $default);
-  }
-  
-  public function add_column($table, $name, $type="string", $length = "128", $null=true, $default=null) {
-    try {
-      if($type=="integer" && $length>11) $length="11";
-			$name = str_replace(" ", "", $name);
-      $column = array($name, $type, $length, $null, $default);
-      $sql = "ALTER TABLE `$table` ADD ";
-      $sql.= $this->build_column_sql($column);
-      $this->pdo->query($sql);
-      $this->output( "...added column $name to $table"."\n" );
-			return true;
-    } catch(Exception $e) {
-      $this->catcher($e);
-    }
-  }
-  
-  public function remove_column($table, $name) {
-    try {
-			$name = str_replace(" ", "", $name);
-      $sql = "ALTER TABLE `$table` DROP `$name`";
-      $this->pdo->query($sql);
-      $this->output( "...removed column $name from $table"."\n" );
-    } catch(Exception $e) {
-      $this->catcher($e);
-    }
-  }
-  
-  public function change_column($table, $name, $type="string", $length = "128", $null=true, $default=null) {
-    try {
-			$name = str_replace(" ", "", $name);	
-      $column = array($name, $type, $length, $null, $default);
-      $sql = "ALTER TABLE `$table` CHANGE `$name` ";
-      $sql.= $this->build_column_sql($column);
-      $this->pdo->query($sql);
-      $this->output( "...changed column $name in $table"."\n" );
-    } catch(Exception $e) {
-      $this->catcher($e);
-    }
-  }
-  
-  public function rename_table($table, $new_name) {
-    try {
-      $sql = "ALTER TABLE `$table` RENAME `$new_name`";
-      $this->pdo->query($sql);
-      $this->output( "...renamed table $table to $new_name"."\n");
-    } catch(Exception $e) {
-      $this->catcher($e);
-    }
-  }
-  
-  public function run_sql($sql) {
-    try {
-      $this->pdo->query($sql);
-      $this->output( "...executed raw sql command"."\n");
-    } catch(Exception $e) {
-      $this->catcher($e);
-    }
-  }
-  
-  protected function output($string) {
-    if(!$this->quiet_mode) {
-      echo $string;
-    }
-  }
-  
-  protected function catcher($e) {
-    $this->output( "Notice: error with query: {$e->getMessage()}"."\n" );
-    return false;
-  }
-  
-  public function up() {}
-  public function down() {}
-  
-}
-
-
-?>
\ No newline at end of file
diff --git a/wax/WXValidations.php b/wax/WXValidations.php
deleted file mode 100644
index e4bac479e79f67d0f29b94ddf3dd835598d5e0ca..0000000000000000000000000000000000000000
--- a/wax/WXValidations.php
+++ /dev/null
@@ -1,155 +0,0 @@
-<?php
-/**
- *  
- * @package PHP-Wax
- * @author Ross Riley
- **/
-class WXValidations
-{
-  const EMAIL =                   '/^[_a-z0-9-]+(\.[_a-z0-9-]+)*@[a-z0-9-]+(\.[a-z0-9-]+)*(\.[a-z]{2,3})$/i';
-  //const UK_POSTCODE =             '/^(GIR0AA)|(TDCU1ZZ)|((([A-PR-UWYZ][0-9][0-9]?)|(([A-PR-UWYZ][A-HK-Y][0-9][0-9]?)|(([A-PR-UWYZ][0-9][A-HJKSTUW])|([A-PR-UWYZ][A-HK-Y][0-9][ABEHMNPRVWXY]))))[0-9][ABD-HJLNP-UW-Z]{2})$/';
-  const UK_POSTCODE =             '/^([A-PR-UWYZ0-9][A-HK-Y0-9][AEHMNPRTVXY0-9]?[ABEHMNPRVWXY0-9]?\s*[0-9][ABD-HJLN-UW-Z]{2}|GIR 0AA)$/i';
-  const USA_ZIPCODE =             '/[[:digit:]]{5}(-[[:digit:]]{4})?/';
-  const USA_DATE =                '/([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})/';
-  const UK_DATE =                 '/([0-9]{1,2})-([0-9]{1,2})-([0-9]{4})/';
-  const NUMBER =                  '/^[+-]?[0-9]*\.?[0-9]+$/';
-  const INTEGER =                 '/^[0-9]*$/';
-  const PRINTABLE =               '/^[[:print:]]{1}/';       
-              	                        
-	protected $extra_validations = array();
-	protected $validations = array();
-	protected static $errors = array();
-	protected $skip_validations = array();
-	protected static $errors_fetched = false;
-	
-	
-	
-	/**
-	 * getter method to retrieve a value from the set array or 
-	 * the customisable extras array. In the event that neither
-	 * are found it returns false
-	 */
-	function __get($field) { 
-	  $constant = strtoupper($field); 	
-  	if(isset($this->extra_validations[$field])) {
-      return $this->extra_validations[$field];	
-  	} elseif(defined("self::$constant")) {
-      return constant("self::$constant");		
-  	} else {
-      return false;	
-  	}
-	}
-	
-	/**
-	 * setter method to alter the values of either exisiting
-	 * values in the private arrays or add a new field into 
-	 * the extras array.
-	 */
-	function __set($field, $value)
-	{
-  	if(isset($this->extra_validations[$field])) {
-      $this->extra_validations[$field] = $value;	
-  	} elseif(isset($this->fixed[$field])) {
-      $this->fixed_validations[$field] = $value;		
-  	} else {
-      $this->extra_validations[$field] = $value;
-  	}
-	}
-	
-	public function get_errors($force = true) {
-		$ret = self::$errors;
-		if(!self::$errors_fetched) {
-	    self::$errors_fetched=true;
-	    return $ret;
-	  }
-		elseif($force) return $ret;
-		else return array();
-	}
-	
-	public function stealth_get_errors() {
-	  return self::$errors;
-	}
-	
-	public function clear_errors() {
-	  self::$errors=array();
-	}
-	
-	public function validate() {
-		if(count(self::$errors) <1) {
-			return true;
-		}
-		return false;
-	}
-	
-	public function skip_validation($field) {
-	  $this->skip_validations[]=$field;
-	}
-	
-	public function add_error($field, $message) {
-		self::$errors[]=array("field"=>$field, "message"=>$message);
-	}
-	
-	public function valid_format($field, $format, $message="is an invalid format", $optional=true, $max_length=0) {
-		if(strlen($this->{$field})<1) {
-			$this->valid_required($field);
-			return false;
-		}
-		if(defined('self::'.strtoupper($format))) {
-			$format = constant('self::'.strtoupper($format));
-		}
-		if($max_length > 0){
-			self::valid_length($field, 0, $max_length);
-		}
-		if(preg_match($format, $this->{$field})) {
-			return true;
-		} else {
-		  $message = $this->{$field}." ".$message;
-			$this->add_error($field, $message);
-			return false;
-		}
-	}
-	
-	public function valid_required($field, $message="is a required field") {
-		if(strlen($this->{$field}) < 1 ) {
-			$this->add_error($field, $message);
-			return false;
-		}
-	}
-	
-	public function valid_length($field, $min, $max=0, $message_short="must be at least", $message_long="must be less than") {
-		if(strlen($this->{$field}) < $min && $min >0 ) {
-			$this->add_error($field, $message_short." {$min} characters");
-			return false;
-		}
-		if(strlen($this->{$field}) > $max && $max > 0 ) {
-			$this->add_error($field, $message_long." {$max} characters");
-			return false;
-		}
-	}
-	
-	public function valid_unique($field, $message="is already taken") {
-		if(!$this->{$field}) {
-			return false;
-		}
-		$class = get_class($this);
-		$obj = new $class;
-		$field_added_slashes = addslashes($this->{$field});
-		$res = $obj->find_all(array("conditions"=>"{$field}='{$field_added_slashes}'"));
-		foreach($res as $row) {
-		  if($row->id != $this->id) {
-			  $this->add_error($field, $message);
-			  return false;
-		  }
-		}
-	}
-	
-	public function valid_confirm($field1, $field2, $message="do not match") {
-		if($this->{$field1} !== $this->{$field2}) {
-			$this->add_error($field1." and ".$field2, $message);
-			return false;
-		}
-	}
-		
-	protected function validations() {}
-	
-}
\ No newline at end of file
diff --git a/wax/helpers/JQueryHelper.php b/wax/helpers/JQueryHelper.php
deleted file mode 100755
index 63b93e14511cfb667fb7899069851b1b6f762859..0000000000000000000000000000000000000000
--- a/wax/helpers/JQueryHelper.php
+++ /dev/null
@@ -1,287 +0,0 @@
-<?php  
-
-/**
- *
- * The JQuery Helpers are taken from the PQuery functions - http://www.ngcoders.com.
- *
- * @package		PHP-WAX
- * @author		Vikas Patial
- * @copyright	Copyright (c) 2006, ngcoders.
- * @license		http://www.gnu.org/copyleft/gpl.html 
- * @link		http://www.ngcoders.com
- * @since		Version 0.1
- * @filesource
- */
-
-class JQueryHelper extends JavascriptHelper  {
-	
-		var $CALLBACKS 	=  	array('beforeSend',
-							'complete',
-							'error',
-							'success');
-		var $CONSTANTS =    array('hide','show','toggle');
-		
-		// after,append,appendTo,before,insertAfter,insertBefore,prepend,prependTo
-				
-
-	public function form_remote_tag($options) {
-		$options['form'] = true;
-		return '<form action="'.$options['url'].'" onsubmit=\''.$this->remote_function($options).'; return false;\' method="'.(isset($options['type'])?$options['type']:'GET').'"  >';			
-	}
-	
-	public function link_to_remote($name,$options=null,$html_options=null) {
-		return $this->link_to_function($name,$this->remote_function($options),$html_options);
-	}
-	
-	public function remote_function($options) {
-	
-		$javascript_options = $this->_options_for_ajax($options);
-		
-		$ajax_function= '$.ajax({'.$javascript_options.'})';
-		
-		$ajax_function=(isset($options['before']))?  $options['before'].';'.$ajax_function : $ajax_function;
-		$ajax_function=(isset($options['after']))?  $ajax_function.';'.$options['after'] : $ajax_function;
-		$ajax_function=(isset($options['condition']))? 'if ('.$options['condition'].') {'.$ajax_function.'}' : $ajax_function;
-		$ajax_function=(isset($options['confirm'])) ? 'if ( confirm(\''.$options['confirm'].'\' ) ) { '.$ajax_function.' } ':$ajax_function;
-		
-		return $ajax_function;
-	
-	}
-	
-	public function visual_effect($name,$element,$options=null) {
-
-		$effect='';
-		$speed    = isset($options['speed'])?(is_numeric($options['speed'])?$options['speed']:'"'.$options['speed'].'"'):'"normal"';
-		$callback = (isset($options['callback']))?',function(){'.$options['callback'].'})':')';
-		
-		switch($name) {
-			case 'animate'	:
-				$params = $this->_options_for_javascript($options,array('hide','show','toggle'));
-				$effect ='$("'.$element.'").animate({'.$params.'},'.$speed.','.(isset($options['easing'])?'"'.$options['easing'].'"':'"linear"').$callback;
-				break;
-			case 'fadeIn':
-			case 'fadeOut':
-			case 'hide':
-			case 'show':
-			case 'slideDown':
-			case 'slideToggle':
-			case 'slideUp':
-				$effect = '$("'.$element.'").'.$name.'('.$speed.$callback;
-				break;
-			case 'hide':
-			case 'show':
-			case 'toggle':
-				$effect = '$("'.$element.'").'.$name.'()';
-				break;
-			case 'fadeTo':
-				$effect = '$("'.$element.'").fadeTo('.$speed.','.$options['opacity'].$callback;
-				break;
-		}
-		return $effect;
-	
-	}
-	
-	public function show($id) {
-		return $this->visual_effect('show',$id);
-	}
-
-	public function toggle($id) {
-		return $this->visual_effect('toggle',$id);
-	}
-	
-	public function hide($id) {
-		return $this->visual_effect('hide',$id);
-	}
-
-	
-	public function ID($id,$extend=null) {
-		return '$("'.$id.'")'.(!empty($extend))?'.'.$extend:'';
-	}
-	
-	public function call($function , $args = null) {
-		$arg_str='';
-		if (is_array($args)) {
-			foreach ($args as $arg){
-				if(!empty($arg_str))$arg_str.=', ';
-				if( is_string($arg)) {
-					$arg_str.="'$arg'";
-				} else {
-					$arg_str.=$arg;
-				}
-			}
-		} else {
-			if (is_string($args)) {
-				$arg_str.="'$args'";
-			} else {
-				$arg_str.=$args;
-			}
-		}
-
-		return "$function($arg_str)";
-	}
-	
-	public function alert($message) {
-		return $this->call('alert',$message);
-	}
-
-	public function assign($variable,$value) {
-		return "$variable = $value;";
-	}
-	
-	public function delay($seconds=1,$script='') {
-		return "setTimeout( function() { $script } , ".($seconds*1000)." )";
-	}
-	
-	public function redirect_to($location) {
-		return $this->assign('window.location.href',$location);
-	}
-	
-	public function periodically_call_remote($options=null) {
-		$frequency=(isset($options['frequency']))?$options['frequency']:10;
-		$code = 'setInterval(function() { '.$this->remote_function($options).' },'.($frequency*1000).')';
-		return $code;
-	}
-	
-	public function observe_field($field_id,$options=null) {
-		if (isset($options['frequency']) && $options['frequency']> 0 ) {
-			return $this->_build_observer(false,$field_id,$options);
-		} else {
-			return $this->_build_observer(true,$field_id,$options);
-		}
-	}
-	
-	// after,append,appendTo,before,insertAfter,insertBefore,prepend,prependTo
-	
-	public function insert_html($position,$id,$html,$type='html') {
-		$html_val= (($type=='html')?'"'.$html.'"':$html);
-		return '$("'.$id.'").'.$position.'('.$html_val.')';
-	}
-	
-	public function replace_html($id,$html,$type='html') {
-		$html_val= (($type=='html')?'"'.$html.'"':$html);
-		return '$("'.$id.'").replace('.$html_val.')';
-	}
-	
-	public function remove($id,$expr=false) {
-		$expr = (($expr)?'"'.$expr.'"':'');
-		return '$("'.$id.'").remove('.$expr.')';
-	}
-	
-	public function clean($id) {
-		return '$("'.$id.'").empty()';
-	}
-		
-	
-	/////////////////////////////////////////////////////////////////////////////////////
-	//                             Private functions 
-	/////////////////////////////////////////////////////////////////////////////////////
-	
-	protected function _build_callbacks($options) {
-		$callbacks=array();
-		foreach ($options as $callback=>$code) {
-			if (in_array($callback,$this->CALLBACKS)) {
-							$callbacks[$callback]='function(response){'.$code.'}';
-						}			
-		}
-		return $callbacks;
-	}
-	
-	protected function _build_observer($event=false,$name,$options=null) {
-
-		$callback = isset($options['function']) ? $options['function'] : $this->remote_function($options);
-		$frequency=(isset($options['frequency']))?$options['frequency']:10;
-		
-		
-		if ($event) {
-			$javascript = '$("'.$name.'").bind("'.$options['event'].'",function(event) {'.$callback.'})';
-				} else {
-			$javascript = 'setInterval(function() { '.$callback.' },'.($frequency*1000).')';
-		}
-
-		return $this->javascript_tag($javascript);
-		
-	}
-	
-	protected function _method_option_to_s($method) {
-		return (strstr($method,"'"))?$method:"'$method'";
-	}
-	
-	protected function _options_for_ajax($options) {
-		if (isset($options['url'])) $js_options['url']    = '"'.$options['url'].'"';
-		
-		if (isset($options['form'])) {
-			$js_options['data']='$(this.elements).serialize()';		
-		}elseif (isset($options['parameters'])){
-			$js_options['data']='$("'.$options['submit'].'").serialize()';
-		}elseif (isset($options['with'])) {
-			$js_options['data']= '"'.$options['with'].'"';
-		}
-		
-		$html_update=(isset($options['position'])?$options['position']:'html');
-		if (isset($options['update']))$options['success']='$("'.$options['update'].'").'.$html_update.'(response);'.(isset($options['success'])?$options['success']:'');
-				
-		$js_options=array_merge($js_options,(is_array($options))?$this->_build_callbacks($options):array());
-		
-		if (isset($options['async']))$js_options['async'] = $options['async'];
-
-		if (isset($options['type'])) $js_options['type'] = '"'.$options['type'].'"';
-		if (isset($options['contentType'])) $js_options['contentType'] = '"'.$options['contentType'].'"';
-		
-		$js_options['dataType'] = (isset($options['dataType']))?'"'.$options['dataType'].'"':'"html"';
-		
-		if (isset($options['timeout'])) $js_options['timeout'] = $options['timeout'];
-		
-		if (isset($options['processData'])) $js_options['processData'] = $options['processData'];
-		if (isset($options['ifModified'])) $js_options['ifModified'] = $options['ifModified'];
-		if (isset($options['global'])) $js_options['global'] = $options['global'];
-			
-		return $this->_options_for_javascript($js_options);
-	}
-	
-	public function button_to_function($name,$function=null) {
-		return '<input type="button" value="'.$name.'" onclick="'.$function.'" />';
-	}
-		
-	public function link_to_function($name,$function,$html_options=null) {
-		return '<a href="'.((isset($html_options['href']))?$html_options['href']:'#').'" onclick=\''.((isset($html_options['onclick']))?$html_options['onclick'].';':'').$function.'; return false;\' />'.$name.'</a>';
-	}
-		
-	/////////////////////////////////////////////////////////////////////////////////////
-	//                             Private functions 
-	/////////////////////////////////////////////////////////////////////////////////////
-	
-	protected function _array_or_string_for_javascript($option) {
-		$return_val='';
-		if(is_array($option))
-		{
-			foreach ($option as $value) {
-				if(!empty($return_val))$ret_val.=', ';
-				$return_val.=$value;
-			}
-			return '['.$return_val.']';
-		} 
-			return "'$option'";	
-	}
-	
-	
-	protected function _options_for_javascript($options,$constants=false) {
-		$return_val='';
-		
-		if (is_array($options)) {
-			
-		foreach ($options as $var=>$val)
-		{
-			if (!empty($return_val)) $return_val.=', ';
-			if(!$constants)$return_val.="$var: $val";
-			else  {
-				$return_val.= $var.' : '.((in_array($val,$constants))?'"'.$val.'"':$val);
-			}
-		}
-		}		
-		return $return_val;
-	}
-
-
-
-	
-}
\ No newline at end of file
diff --git a/wax/helpers/JavascriptHelper.php b/wax/helpers/JavascriptHelper.php
deleted file mode 100644
index 85336093d22cb47c346b6b9f9722eaf19bfb0c96..0000000000000000000000000000000000000000
--- a/wax/helpers/JavascriptHelper.php
+++ /dev/null
@@ -1,63 +0,0 @@
-<?php
-/**
- *
- * @package PHP-Wax
- * @author Ross Riley
- **/
- 
-class JavascriptHelper extends WXHelpers {
-  
-  function __construct() {
-    $this->javascript_path = '/javascripts';
-  }
-  
-  protected function options_for_javascript($options) {
-    $javascript = array();
-    if(is_array($options)) {
-      $javascript = array_map(create_function('$k, $v', 'return "{$k}:{$v}";'), array_keys($options), array_values($options));
-      sort($javascript);
-    }
-    return '{' . implode(', ', $javascript) . '}';
-  }
-  
-  private function array_or_string_for_javascript($option) {
-    if(is_array($option)) {
-        $js_option = "['" . implode('\',\'', $option) . "']";
-    } elseif (!is_null($option)) {
-        $js_option = "'{$option}'";
-    }
-    return $js_option;
-  }
-  
-     
-  # Returns a link that'll trigger a javascript $function using the 
-  # onclick handler and return false after the fact.
-  #
-  # Examples:
-  #   link_to_function("Greeting", "alert('Hello world!')")
-  #   link_to_function(image_tag("delete"), "if confirm('Really?'){ do_delete(); }")
-  public function link_to_function($name, $function, $html_options = array()) {
-      return $this->content_tag("a", $name, array_merge(array('href' => "#", 'onclick' => "{$function}; return false;"), $html_options));
-  }
-    
-  # Escape carrier returns and single and double quotes for JavaScript segments.
-  public function escape_javascript($javascript) {
-      return preg_replace('/\r\n|\n|\r/', "\\n",
-             preg_replace_callback('/["\']/', create_function('$m', 'return "\\{$m}";'),
-             (!is_null($javascript) ? $javascript : '')));
-  }
-  
-  # Returns a JavaScript tag with the $content inside. Example:
-  #   javascript_tag("alert('All is good')") => <script type="text/javascript">alert('All is good')</script>
-  public function javascript_tag($content) {
-      return $this->content_tag("script", $this->javascript_cdata_section($content), array('type' => "text/javascript"));
-  }
-  
-  public function javascript_cdata_section($content) {
-      return "\n//" . $this->cdata_section("\n{$content}\n//") . "\n";
-  }
-  
-  
-}
-
-?>
\ No newline at end of file
diff --git a/wax/helpers/PrototypeHelper.php b/wax/helpers/PrototypeHelper.php
deleted file mode 100755
index 68180a245d00e7180d98ff762f91f6a3d5a07a9a..0000000000000000000000000000000000000000
--- a/wax/helpers/PrototypeHelper.php
+++ /dev/null
@@ -1,384 +0,0 @@
-<?php
-/**
- *
- * @package PHP-Wax
- * @author Ross Riley
- **/
- 
-class PrototypeHelper extends JavascriptHelper {
-
-  public function __construct() {
-    $this->javascript_callbacks = array('uninitialized', 'loading', 'loaded', 'interactive', 'complete', 'failure', 'success');    
-    $this->ajax_options = array_merge(array('before', 'after', 'condition', 'url', 'asynchronous', 'method', 'insertion', 'position', 'form', 'with', 'update', 'script'), $this->javascript_callbacks);
-    $this->javascript_path = '/javascripts';
-  }
-  
-  protected function options_for_ajax($options) {
-    $js_options = $this->build_callbacks($options);    
-    $js_options['asynchronous'] = ($options['type'] != 'synchronous') ? "true" : "false";
-    if($options['method']) {
-        $js_options['method'] = $this->method_option_to_s($options['method']);
-    }
-    if($options['position']) {
-        $js_options['insertion'] = "Insertion." . camelize($options['position']);
-    }
-    $js_options['evalScripts'] = $options['script'] ? $options['script'] : "true";
-    
-    if($options['form']) {
-        $js_options['parameters'] = "Form.serialize(this)";
-    } elseif($options['submit']) {
-        $js_options['parameters'] = "Form.serialize(document.getElementById('{$options['submit']}'))";
-    } elseif($options['with']) {
-        $js_options['parameters'] = $options['with'];
-    }
-    return $this->options_for_javascript($js_options);
-  }
-  
-  protected function method_option_to_s($method) {
-    return ((is_string($method) && !strstr($method, "'")) ? "'{$method}'" : $method);
-  }
-  
-  protected function build_observer($klass, $name, $options = array()) {
-    if($options['update']) {
-        if(!$options['with']) {
-            $options['with'] = 'value';
-        }
-    }
-    $callback = $this->remote_function($options);
-    $javascript  = "new {$klass}('{$name}', ";
-    if($options['frequency']) {
-        $javascript .= "{$options['frequency']}, ";
-    }
-    $javascript .= "function(element, value) {";
-    $javascript .= "{$callback}})";
-    return $this->javascript_tag($javascript);
-  }
-  
-  protected function build_callbacks($options) {
-    $callbacks = array();
-    foreach($options as $callback => $code) {
-        if(in_array($callback, $this->javascript_callbacks)) {
-            $name = 'on' . capitalize($callback);
-            $callbacks[$name] = "function(request){{$code}}";
-        }
-    }
-    return $callbacks;
-  }
-  
-  protected function remove_ajax_options($options) {
-    if(is_array($options)) {
-        foreach($options as $option_key => $option_value) {
-            if(!in_array($option_key, $this->ajax_options)) {
-                $new_options[$option_key] = $option_value;  
-            }  
-        } 
-        if(is_array($new_options)) {
-            $options = $new_options; 
-        }           
-    }    
-    return $options;    
-  }
-     
-  
-  # Returns a link to a remote action defined by <tt>$options['url']</tt> 
-  # (using the url_for() format) that's called in the background using 
-  # XMLHttpRequest. The result of that request can then be inserted into a
-  # DOM object whose id can be specified with <tt>$options['update']</tt>. 
-  #
-  # Examples:
-  #  link_to_remote("Delete this post", array("update" => "posts", array("url" => array(":action" => "destroy", ":id" => $post->id)))
-  #  link_to_remote(image_tag("refresh"), array("update" => "emails", "url" => array(":action" => "list_emails")))
-  #  link_to_remote(image_tag("refresh"), array("update" => "emails", "url" => "/posts/list_emails"))
-  #
-  # You can also specify a hash for <tt>$options['update']</tt> to allow for
-  # easy redirection of output to an other DOM element if a server-side error occurs:
-  #
-  # Example:
-  #  link_to_remote("Delete this post", array(
-  #      "url" => array(":action" => "destroy", ":id" => $post->id),
-  #      "update" => array("success" => "posts", "failure" => "error")
-  #      ))
-  #
-  # Optionally, you can use the <tt>$options['position']</tt> parameter to influence
-  # how the target DOM element is updated. It must be one of 
-  # <tt>before</tt>, <tt>top</tt>, <tt>bottom</tt>, or <tt>after</tt>.
-  #
-  # By default, these remote requests are processed asynchronous during 
-  # which various JavaScript callbacks can be triggered (for progress indicators and
-  # the likes). All callbacks get access to the <tt>request</tt> object,
-  # which holds the underlying XMLHttpRequest. 
-  #
-  # To access the server response, use <tt>request.responseText</tt>, to
-  # find out the HTTP status, use <tt>request.status</tt>.
-  #
-  # Example:
-  #   link_to_remote($word, array(
-  #       "url" => array(":action" => "undo", "n" => $word_counter ),
-  #       "complete" => "undoRequestCompleted(request)"))
-  #
-  # The callbacks that may be specified are (in order):
-  #
-  # <tt>loading</tt>::       Called when the remote document is being 
-  #                           loaded with data by the browser.
-  # <tt>loaded</tt>::        Called when the browser has finished loading
-  #                           the remote document.
-  # <tt>interactive</tt>::   Called when the user can interact with the 
-  #                           remote document, even though it has not 
-  #                           finished loading.
-  # <tt>success</tt>::       Called when the XMLHttpRequest is completed,
-  #                           and the HTTP status code is in the 2XX range.
-  # <tt>failure</tt>::       Called when the XMLHttpRequest is completed,
-  #                           and the HTTP status code is not in the 2XX
-  #                           range.
-  # <tt>complete</tt>::      Called when the XMLHttpRequest is complete 
-  #                           (fires after success/failure if they are present).,
-  #                     
-  # You can further refine <tt>success</tt> and <tt>failure</tt> by adding additional 
-  # callbacks for specific status codes:
-  #
-  # Example:
-  #   link_to_remote($word,
-  #       "url" => array(":action" => "action"),
-  #       "failure" => "alert('HTTP Error ' + request.status + '!')")
-  #
-  # A status code callback overrides the success/failure handlers if present.
-  #
-  # If you for some reason or another need synchronous processing (that'll
-  # block the browser while the request is happening), you can specify 
-  # <tt>$options['type'] = "synchronous"</tt>.
-  #
-  # You can customize further browser side call logic by passing
-  # in JavaScript code snippets via some optional parameters. In
-  # their order of use these are:
-  #
-  # <tt>confirm</tt>::      Adds confirmation dialog.
-  # <tt>condition</tt>::    Perform remote request conditionally
-  #                          by this expression. Use this to
-  #                          describe browser-side conditions when
-  #                          request should not be initiated.
-  # <tt>before</tt>::       Called before request is initiated.
-  # <tt>after</tt>::        Called immediately after request was
-  #                          initiated and before <tt>:loading</tt>.
-  # <tt>submit</tt>::       Specifies the DOM element ID that's used
-  #                          as the parent of the form elements. By 
-  #                          default this is the current form, but
-  #                          it could just as well be the ID of a
-  #                          table row or any other DOM element.
-  public function link_to_remote($name, $options = array(), $html_options = array()) {
-      return $this->link_to_function($name, $this->remote_function($options), $html_options);
-  }
-  
-  # Periodically calls the specified url (<tt>$options['url']</tt>) every <tt>options[:frequency]</tt> seconds (default is 10).
-  # Usually used to update a specified div (<tt>$options['update']</tt>) with the results of the remote call.
-  # The options for specifying the target with 'url' and defining callbacks is the same as link_to_remote().
-  public function periodically_call_remote($options = array()) {
-      $frequency = $options['frequency'] ? $options['frequency'] : 10; # every ten seconds by default
-      $code = "new PeriodicalExecuter(function() {" . $this->remote_function($options) . "}, {$frequency})";
-      return $this->javascript_tag($code);
-  }
-  
-  # Returns a form tag that will submit using XMLHttpRequest in the background instead of the regular 
-  # reloading POST arrangement. Even though it's using JavaScript to serialize the form elements, the form submission 
-  # will work just like a regular submission as viewed by the receiving side (all elements available in $_REQUEST).
-  # The options for specifying the target with :url and defining callbacks is the same as link_to_remote().
-  #
-  # A "fall-through" target for browsers that doesn't do JavaScript can be specified with the :action/:method options on :html
-  #
-  #   form_remote_tag("html" => array("action" => url_for(":controller" => "some", ":action" => "place")))
-  # The Hash passed to the 'html' key is equivalent to the options (2nd) argument in the FormTagHelper::form_tag() method.
-  #
-  # By default the fall-through action is the same as the one specified in the 'url' (and the default method is 'post').
-  public function form_remote_tag($options = array()) {
-      $options['form'] = true;       
-      if (!$options['html']) {
-          $options['html'] = array();
-      }
-      $options['html']['onsubmit'] = $this->remote_function($options) . "; return false;";
-      if($options['html']['action']) {
-          $url_for_options = $options['html']['action'];
-      } else {
-          $url_for_options = url_for($options['url']);    
-      }
-      if(!$options['html']['method']) {
-          $options['html']['method'] = "post";
-      }
-      return $this->tag("form", $options['html'], true);
-  }
-      
-  # Returns a button input tag that will submit form using XMLHttpRequest in the background instead of regular
-  # reloading POST arrangement. <tt>$options</tt> argument is the same as in <tt>form_remote_tag()</tt>
-  public function submit_to_remote($name, $value, $options = array()) {
-      if(!isset($options['with'])) {
-          $options['with'] = 'Form.serialize(this.form)';
-      }
-      if(!$options['html']) {
-          $options['html'] = array();
-      }
-      $options['html']['type'] = 'button';
-      $options['html']['onclick'] = $this->remote_function($options) . "; return false;";
-      $options['html']['name'] = $name;
-      $options['html']['value'] = $value;      
-      return $this->tag("input", $options['html']);
-  }
-  
-  # Returns a Javascript function (or expression) that'll update a DOM element according to the options passed.
-  #
-  # * <tt>content</tt>: The content to use for updating. Can be left out if using block, see example.
-  # * <tt>action</tt>: Valid options are :update (assumed by default), :empty, :remove
-  # * <tt>position</tt> If the :action is :update, you can optionally specify one of the following positions: :before, :top, :bottom, :after.
-  #
-  # Examples:
-  #   javascript_tag(update_element_function(
-  #         "products", :position => :bottom, :content => "<p>New product!</p>")) 
-  #
-  #    replacement_function = update_element_function("products") do 
-  #     <p>Product 1</p>
-  #     <p>Product 2</p>
-  #    end 
-  #   javascript_tag(replacement_function) 
-  #
-  # This method can also be used in combination with remote method call where the result is evaluated afterwards to cause
-  # multiple updates on a page. Example:
-  #
-  #   # Calling view
-  #    form_remote_tag(array("url" => array(":action" => "buy"), "complete" => evaluate_remote_response())) 
-  #    all the inputs here...
-  #
-  #   # Controller action
-  #   function buy() {
-  #       $product = new Product;
-  #       $this->product = $product->find(1);
-  #   }
-  #
-  #   # Returning view
-  #    update_element_function(
-  #         "cart", array(":action" => "update", "position" => "bottom", 
-  #         "content" => "<p>New Product: #{$product->name}</p>")) 
-  #    update_element_function("status", array("binding" => $binding) do 
-  #     You've bought a new product!
-  #    end 
-  #
-  public function update_element_function($element_id, $options = array(), $block = null) {   
-      $content = $this->escape_javascript(($options['content'] ? $options['content'] : null));
-      if(!is_null($block)) {
-          $content = $this->escape_javascript($this->capture($block));
-      }
-      switch((isset($options['action']) ? $options['action'] : 'update')) {
-          case 'update':
-              if($options['position']) {
-                  $javascript_function = "new Insertion." . camelize($options['position']) . "('{$element_id}','{$content}')";
-              } else {
-                  $javascript_function = "$('{$element_id}').innerHTML = '{$content}'";
-              }
-              break;
-          case 'empty':
-              $javascript_function = "$('{$element_id}').innerHTML = ''";
-              break;
-          case 'remove':
-              $javascript_function = "Element.remove('{$element_id}')";
-              break;
-          default:
-              $this->controller_object->raise("Invalid action, choose one of 'update', 'remove', 'empty'", "ArgumentError");
-      }       
-      $javascript_function .= ";\n";
-      return ($options['binding'] ? $javascript_function . $options['binding'] : $javascript_function);
-  }
-  
-  # Returns 'eval(request.responseText)' which is the Javascript function that form_remote_tag can call in :complete to
-  # evaluate a multiple update return document using update_element_function calls.
-  public function evaluate_remote_response() {
-      return "eval(request.responseText)";
-  }
-  
-  
-  /*
-  # Returns the javascript needed for a remote function.
-  # Takes the same arguments as link_to_remote.
-  # 
-  # Example:
-  #   <select id="options" onchange="<?= remote_function(array("update" => "options", "url" => array(":action" => "update_options"))) ?>">
-  #     <option value="0">Hello</option>
-  #     <option value="1">World</option>
-  #   </select>
-  */
-  public function remote_function($options) {
-      $javascript_options = $this->options_for_ajax($options);       
-      $update = '';
-      if(is_array($options['update'])) {
-          $update  = array();
-          if(isset($options['update']['success'])) {
-              $update[] = "success:'{$options['update']['success']}'";
-          }
-          if($options['update']['failure']) {
-              $update[] = "failure:'{$options['update']['failure']}'";
-          }
-          $update = '{' . implode(',', $update) . '}';
-      } elseif($options['update']) {
-          $update .= "'{$options['update']}'";
-      }   
-          
-      $function  = empty($update) ? "new Ajax.Request(" : "new Ajax.Updater({$update}, ";
-      $function .= "'" . url_for($options['url']) . "'";
-      $function .= ", " . $javascript_options . ")";
-      
-      if($options['before']) {
-          $function = "{$options['before']}; {$function}";
-      }
-      if($options['after']) { 
-          $function = "{$function}; {$options['after']}";
-      }
-      if($options['condition']) {
-          $function = "if ({$options['condition']}) { {$function}; }";
-      }
-      if($options['confirm']) {
-          $function = "if (confirm('" . $this->escape_javascript($options['confirm']) . "')) { {$function}; }";
-      }
-      return $function;
-  }
-  
-  # Observes the field with the DOM ID specified by +field_id+ and makes
-  # an AJAX call when its contents have changed.
-  # 
-  # Required $options are:
-  # <tt>url</tt>::       +url_for+-style options for the action to call
-  #                       when the field has changed.
-  # 
-  # Additional options are:
-  # <tt>frequency</tt>:: The frequency (in seconds) at which changes to
-  #                       this field will be detected. Not setting this
-  #                       option at all or to a value equal to or less than
-  #                       zero will use event based observation instead of
-  #                       time based observation.
-  # <tt>update</tt>::    Specifies the DOM ID of the element whose 
-  #                       innerHTML should be updated with the
-  #                       XMLHttpRequest response text.
-  # <tt>with</tt>::      A JavaScript expression specifying the
-  #                       parameters for the XMLHttpRequest. This defaults
-  #                       to 'value', which in the evaluated context 
-  #                       refers to the new field value.
-  #
-  # Additionally, you may specify any of the options documented in
-  # link_to_remote().
-  public function observe_field($field_id, $options = array()) {
-      if($options['frequency'] > 0) {
-          return $this->build_observer('Form.Element.Observer', $field_id, $options);
-      } else {
-          return $this->build_observer('Form.Element.EventObserver', $field_id, $options);
-      }
-  }
-  
-  # Like observe_field(), but operates on an entire form identified by the
-  # DOM ID $form_id. $options are the same as observe_field(), except 
-  # the default value of the <tt>with</tt> option evaluates to the
-  # serialized (request string) value of the form.
-  public function observe_form($form_id, $options = array()) {
-      if($options['frequency']) {
-          return $this->build_observer('Form.Observer', $form_id, $options);
-      } else {
-          return $this->build_observer('Form.EventObserver', $form_id, $options);
-      }
-  }
-
-  
-  
-}
\ No newline at end of file
diff --git a/wax/helpers/ScriptaculousHelper.php b/wax/helpers/ScriptaculousHelper.php
deleted file mode 100755
index f03746af043f52d694aec5931c9b8a707af67dc0..0000000000000000000000000000000000000000
--- a/wax/helpers/ScriptaculousHelper.php
+++ /dev/null
@@ -1,234 +0,0 @@
-<?php
-/**
- *
- * @package PHP-Wax
- * @author Ross Riley
- **/
- 
-class ScriptaculousHelper extends PrototypeHelper {
-  
-  # Returns a JavaScript snippet to be used on the AJAX callbacks for starting
-  # visual effects.
-  #
-  # This method requires the inclusion of the script.aculo.us JavaScript library.
-  #
-  # Example:
-  #   link_to_remote("Reload", array("update" => "posts", 
-  #         "url" => array(":action" => "reload"), 
-  #         "complete" => visual_effect("highlight", "posts", array("duration" => 0.5)))
-  #
-  # If no element_id is given, it assumes "element" which should be a local
-  # variable in the generated JavaScript execution context. This can be used
-  # for example with drop_receiving_element:
-  #
-  #   drop_receving_element (...), "loading" => visual_effect("fade")
-  #
-  # This would fade the element that was dropped on the drop receiving element.
-  #
-  # You can change the behaviour with various options, see
-  # http://script.aculo.us for more documentation.
-  public function visual_effect($name, $element_id = false, $js_options = array()) {
-      $element = ($element_id ? "'{$element_id}'" : "element");
-      if($js_options['queue']) {
-          $js_options['queue'] = "'{$js_options['queue']}'";
-      }
-      return "new Effect." . camelize($name, true) . "({$element}," . $this->options_for_javascript($js_options) . ")";
-  }
-  
-  # Makes the element with the DOM ID specified by +element_id+ sortable
-  # by drag-and-drop and make an AJAX call whenever the sort order has
-  # changed. By default, the action called gets the serialized sortable
-  # element as parameters.
-  #
-  # This method requires the inclusion of the script.aculo.us JavaScript library.
-  #
-  # Example:
-  #    sortable_element("my_list", array("url" => array(":action" => "order"))) 
-  #
-  # In the example, the action gets a "my_list" array parameter 
-  # containing the values of the ids of elements the sortable consists 
-  # of, in the current order.
-  #
-  # You can change the behaviour with various options, see
-  # http://script.aculo.us for more documentation.
-  public function sortable_element($element_id, $options = array()) {
-      if(!$options['with']) {
-          $options['with'] = "Sortable.serialize('{$element_id}')";
-      }
-      if(!$options['onUpdate']) {
-          $options['onUpdate'] = "function(){" . $this->remote_function($options) . "}";
-      }
-      $options = $this->remove_ajax_options($options);
-      foreach(array('tag', 'overlap', 'constraint', 'handle') as $option) {
-          if($options[$option]) {
-              $options[$option] = "'{$options[$option]}'";
-          }
-      }
-      
-      if($options['containment']) {
-          $options['containment'] = $this->array_or_string_for_javascript($options['containment']);
-      }
-      if($options['only']) {
-          $options['only'] = $this->array_or_string_for_javascript($options['only']);
-      }
-      return $this->javascript_tag("Sortable.create('{$element_id}', " . $this->options_for_javascript($options) . ")");
-  }
-  
-  # Makes the element with the DOM ID specified by $element_id draggable.
-  #
-  # This method requires the inclusion of the script.aculo.us JavaScript library.
-  #
-  # Example:
-  #    draggable_element("my_image", array("revert" => true))
-  # 
-  # You can change the behaviour with various options, see
-  # http://script.aculo.us for more documentation. 
-  public function draggable_element($element_id, $options = array()) {
-      return $this->javascript_tag("new Draggable('{$element_id}', " . $this->options_for_javascript($options) . ")");
-  }
-  
-  # Makes the element with the DOM ID specified by $element_id receive
-  # dropped draggable elements (created by draggable_element).
-  # and make an AJAX call  By default, the action called gets the DOM ID of the
-  # element as parameter.
-  #
-  # This method requires the inclusion of the script.aculo.us JavaScript library.
-  #
-  # Example:
-  #    drop_receiving_element("my_cart", array("url" => array(":controller" => "cart", ":action" => "add"))) 
-  #
-  # You can change the behaviour with various options, see
-  # http://script.aculo.us for more documentation.
-  public function drop_receiving_element($element_id, $options = array()) {
-      if(!$options['with']) {
-          $options['with'] = "'id=' + encodeURIComponent(element.id)";
-      }
-      if(!$options['onDrop']) {
-          $options['onDrop'] = "function(element){" . $this->remote_function($options) . "}";
-      }
-      $options = $this->remove_ajax_options($options);
-      if($options['accept']) {
-          $options['accept'] = $this->array_or_string_for_javascript($options['accept']);  
-      }  
-      if($options['hoverclass']) {
-          $options['hoverclass'] = "'{$options['hoverclass']}'";
-      }
-      return $this->javascript_tag("Droppables.add('{$element_id}', " . $this->options_for_javascript($options) . ")");
-  }
-  
-  /**
-   * wrapper for script.aculo.us/prototype Ajax.Autocompleter.
-   * @param string name value of input field
-   * @param string default value for input field
-   * @param array input tag options. (size, autocomplete, etc...)
-   * @param array completion options. (use_style, etc...)
-   *
-   * @return string input field tag, div for completion results, and
-   *                 auto complete javascript tags
-   */
-  public function auto_complete_field($name, $url, $value="", $tag_options = array(), $completion_options = array()) {
-    $javascript = text_field_tag($name, $value, $tag_options, array(), false);
-    $javascript .= $this->content_tag('div', '' , array('id' => "{$name}_auto_complete", 'class' => 'auto_complete'));
-    $javascript .= $this->build_auto_complete_field($name, $url, $completion_options);
-    return $javascript;
-  }
-  
-  /**
-   * wrapper for script.aculo.us/prototype Ajax.Autocompleter.
-   * @param string id value of input field
-   * @param string url of module/action to execute for autocompletion
-   * @param array completion options
-   * @return string javascript tag for Ajax.Autocompleter
-   */
-  protected function build_auto_complete_field($field_id, $url, $options = array()) {
-    $javascript = "var {$field_id}_auto_completer = ";
-    $javascript .= "new Ajax.Autocompleter(";  
-    $javascript .= "'$field_id', ";
-    if (isset($options['update'])) {
-      $javascript .= "'".$options['update']."', ";
-    } else {
-      $javascript .= "'{$field_id}_auto_complete', ";
-    }
-    $javascript .= "'".url_for($url)."'";
-    $js_options = array();
-    if (isset ($options['with'])) $js_options['callback'] = "function(element, value) { return".$options['with']."}";
-    if (isset($options['indicator'])) $js_options['indicator']  = "'".$options['indicator']."'";
-    if (isset($options['on_show'])) $js_options['onShow'] = $options['on_show'];
-    if (isset($options['on_hide'])) $js_options['onHide'] = $options['on_hide'];
-    if (isset($options['min_chars'])) $js_options['minChars'] = $options['min_chars'];
-    if (isset($options['frequency'])) $js_options['frequency'] = $options['frequency'];
-    if (isset($options['update_element'])) $js_options['updateElement'] = $options['update_element'];
-    if (isset($options['after_update_element'])) $js_options['afterUpdateElement'] = $options['after_update_element'];
-    $javascript .= ', '.$this->options_for_javascript($js_options).');';
-    return $this->javascript_tag($javascript);
-  }
-  
-  /**
-   * wrapper for script.aculo.us/prototype Ajax.Autocompleter.
-   * @param string name id of field that can be edited
-   * @param string url of module/action to be called when ok is clicked
-   * @param array editor tag options. (rows, cols, highlightcolor, highlightendcolor, etc...)
-   *
-   * @return string javascript to manipulate the id field to allow click and edit functionality
-   */
-  public function in_place_editor($name, $url, $editor_options = array()) {
-    $default_options = array('tag' => 'span', 'id' => '\''.$name.'_in_place_editor', 'class' => 'in_place_editor_field');
-  
-    return $this->build_in_place_editor($name, $url, array_merge($default_options, $editor_options));
-  }
-  
-  /*
-   * Makes an HTML element specified by the DOM ID '$field_id' become an in-place
-   * editor of a property.
-   *
-   * A form is automatically created and displayed when the user clicks the element,
-   * something like this:
-   * <form id="myElement-in-place-edit-form" target="specified url">
-   *   <input name="value" text="The content of myElement"/>
-   *   <input type="submit" value="ok"/>
-   *   <a onclick="javascript to cancel the editing">cancel</a>
-   * </form>
-   *
-   * The form is serialized and sent to the server using an AJAX call, the action on
-   * the server should process the value and return the updated value in the body of
-   * the reponse. The element will automatically be updated with the changed value
-   * (as returned from the server).
-   *
-   * Required '$options' are:
-   * 'url'                 Specifies the url where the updated value should
-   *                       be sent after the user presses "ok".
-   *
-   * Addtional '$options' are:
-   * 'rows'                Number of rows (more than 1 will use a TEXTAREA)
-   * 'cancel_text'         The text on the cancel link. (default: "cancel")
-   * 'save_text'           The text on the save link. (default: "ok")
-   * 'external_control'    The id of an external control used to enter edit mode.
-   * 'options'             Pass through options to the AJAX call (see prototype's Ajax.Updater)
-   * 'with'                JavaScript snippet that should return what is to be sent
-   *                       in the AJAX call, 'form' is an implicit parameter
-   */
-  protected function build_in_place_editor($field_id, $url, $options = array()) {
-    $javascript = "new Ajax.InPlaceEditor(";
-    $javascript .= "'$field_id', ";
-    $javascript .= "'" . url_for($url) . "'";  
-    $js_options = array();
-    
-    if (isset($options['cancel_text'])) $js_options['cancelText'] = "'".$options['cancel_text']."'";
-    if (isset($options['save_text'])) $js_options['okText'] = "'".$options['save_text']."'";
-    if (isset($options['cols'])) $js_options['cols'] = $options['cols'];
-    if (isset($options['rows'])) $js_options['rows'] = $options['rows'];
-    if (isset($options['external_control'])) $js_options['externalControl'] = $options['external_control'];
-    if (isset($options['options'])) $js_options['ajaxOptions'] = $options['options'];
-    if (isset($options['with'])) $js_options['callback'] = "function(form) { return".$options['with']."}";
-    if (isset($options['highlightcolor'])) $js_options['highlightcolor'] = "'".$options['highlightcolor']."'";
-    if (isset($options['highlightendcolor'])) $js_options['highlightendcolor'] = "'".$options['highlightendcolor']."'";
-    if(isset($options['loadTextURL'])) $js_options['loadTextURL'] =  "'".$options['loadTextURL']."'";
-    $javascript .= ', '.$this->options_for_javascript($js_options);
-    $javascript .= ');';
-    return $this->javascript_tag($javascript);
-  }
-  
-}
-
-
-?>
\ No newline at end of file
diff --git a/wax/tests/TestWaxUrl.php b/wax/tests/TestWaxUrl.php
index 34c51688d2a263104c9d27c22f17291984bfb774..02f46540f8fb0321e3059011a45efdd2fd9e87b8 100644
--- a/wax/tests/TestWaxUrl.php
+++ b/wax/tests/TestWaxUrl.php
@@ -10,27 +10,28 @@ class TestWaxUrl extends WXTestCase {
       echo "\n"."-------------"."\n";
     }
     
-    // public function test_basic_map() {
-    //   $_GET["route"]="mycontroller/myaction/myid";
-    //   WaxUrl::perform_mappings();
-    //   $this->assertEqual(WaxUrl::get("controller"), "mycontroller");
-    //   $this->assertEqual(WaxUrl::get("action"), "myaction");
-    //   $this->assertEqual(WaxUrl::get("id"), "myid");
-    // }
-    // 
-    // public function test_default_map() {
-    //   $_GET["route"]="";
-    //   WaxUrl::perform_mappings();
-    //   $this->assertEqual(WaxUrl::get("controller"), "page");
-    // }
-    // 
-    // public function test_pattern_map() {
-    //   $_GET["route"]="blog/tech/5";
-    //   WaxUrl::map("blog/:category/:id", array("controller"=>"blog", "action"=>"show"));
-    //   WaxUrl::perform_mappings();
-    //   $this->assertEqual(WaxUrl::get("controller"), "blog");
-    //   $this->assertEqual(WaxUrl::get("category"), "tech");
-    // }
+    public function test_basic_map() {
+      $_GET["route"]="mycontroller/myaction/myid";
+      WaxUrl::perform_mappings();
+      $this->assertEqual(WaxUrl::get("controller"), "mycontroller");
+      $this->assertEqual(WaxUrl::get("action"), "myaction");
+      $this->assertEqual(WaxUrl::get("id"), "myid");
+    }
+    
+    public function test_default_map() {
+      $_GET["route"]="";
+      WaxUrl::perform_mappings();
+      $this->assertEqual(WaxUrl::get("controller"), "page");
+    }
+    
+    public function test_pattern_map() {
+      $_GET["route"]="blog/tech/5";
+      WaxUrl::map("blog/:category/:id", array("controller"=>"blog", "action"=>"show"));
+      WaxUrl::perform_mappings();
+      $this->assertEqual(WaxUrl::get("controller"), "blog");
+      $this->assertEqual(WaxUrl::get("category"), "tech");
+      $this->assertEqual(WaxUrl::get("id"), "5");
+    }
     
     public function test_wildcard_map() {
       $_GET["route"]="article/tech/humour/pics";
@@ -40,6 +41,11 @@ class TestWaxUrl extends WXTestCase {
       $this->assertEqual(count(WaxUrl::get("tags")), 3);
     }
     
+    public function test_formats() {
+      $_GET["route"]="sitemap.xml";
+      WaxUrl::perform_mappings();
+    }
+    
    
 }
 
-- 
1.5.4


